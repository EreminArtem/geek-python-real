"""
1. Написать генератор нечётных чисел от 1 до n (включительно),
используя ключевое слово yield
2. * (вместо 1) Решить задачу генерации нечётных чисел от 1 до n (включительно),
не используя ключевое слово yield.
"""
from itertools import zip_longest


def odd_nums(n):
    # for i in range(1, n + 1, 2):
    #     yield i
    return (i for i in range(1, n + 1, 2))


odd_to_15 = odd_nums(15)
print(next(odd_to_15))
print(next(odd_to_15))
print(next(odd_to_15))
print(next(odd_to_15))

"""
3. Есть два списка:
tutors = [
    'Иван', 'Анастасия', 'Петр', 'Сергей', 
    'Дмитрий', 'Борис', 'Елена'
]
klasses = [
    '9А', '7В', '9Б', '9В', '8Б', '10А', '10Б', '9А'
]
Необходимо реализовать генератор, возвращающий кортежи вида (<tutor>, <klass>), например:
('Иван', '9А')
('Анастасия', '7В')
...
Количество генерируемых кортежей не должно быть больше длины списка tutors. Если в списке klasses меньше элементов, 
чем в списке tutors, необходимо вывести последние кортежи в виде: (<tutor>, None), например:
('Станислав', None)

### Доказать, что вы создали именно генератор. Проверить его работу вплоть до истощения. 
Подумать, в каких ситуациях генератор даст эффект. 
"""


def zip_lists():
    tutors = [
        'Иван', 'Анастасия', 'Петр', 'Сергей',
        'Дмитрий', 'Борис', 'Елена', 'Станислав'
    ]
    klasses = [
        '9А', '7В', '9Б', '9В', '8Б', '10А', '10Б'
    ]
    return ((t, k) for t, k in zip_longest(tutors, klasses))


# klass_gen = zip_lists()
# print(next(klass_gen))
# print(next(klass_gen))
# print(next(klass_gen))
# print(next(klass_gen))
# print(next(klass_gen))
# print(next(klass_gen))
# print(next(klass_gen))
# print(next(klass_gen))
# print(next(klass_gen))

"""
### 4. Представлен список чисел. Необходимо вывести те его элементы, значения которых больше предыдущего, например:
src = [300, 2, 12, 44, 1, 1, 4, 10, 7, 1, 78, 123, 55]
result = [12, 44, 4, 10, 78, 123]
"""


def numbers():
    src = [300, 2, 12, 44, 1, 1, 4, 10, 7, 1, 78, 123, 55, 100]
    return [src[i] for i in range(1, len(src)) if src[i] > src[i - 1]]


print(numbers())

"""
5. Подумайте, как можно сделать оптимизацию кода по памяти, по скорости.
Представлен список чисел. Определить элементы списка, не имеющие повторений. 
Сформировать из этих элементов список с сохранением порядка их следования в исходном списке, например:
src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
result = [23, 1, 3, 10, 4, 11]
"""


def unique_numbers():
    src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
    return [i for i in src if src.count(i) < 2]

    # я думаю, что каунт проходит весь список, то есть если я буду сам идти по списку в поисках повторений,
    # в худшем случае будет тоже самое, но в среднем будет лучше потом что
    # в большинстве случаев не придётся доходить до конца списка.
    # однако я не знаю как реализован метод count, может он написан на C и тогда он по идее должен быть намного быстрее


print(unique_numbers())
